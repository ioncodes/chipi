//! Rust code generation from validated definitions and decision trees.
//!
//! Generates clean, idiomatic Rust code with an `impl` block containing a `decode()` function
//! and an enum representing all instruction variants with their fields.

use std::fmt::Write;

use crate::tree::DecodeNode;
use crate::types::*;

/// Generate Rust source code from a validated definition and dispatch tree.
///
/// The output includes:
/// - An enum with all instruction variants
/// - A `decode()` function using efficient match statements
/// - Proper type conversions and bit extraction
pub fn generate_code(def: &ValidatedDef, tree: &DecodeNode) -> String {
    let mut out = String::new();

    writeln!(out, "// Auto-generated by chipi. Do not edit.").unwrap();
    writeln!(out).unwrap();

    // Imports
    for imp in &def.imports {
        writeln!(out, "use {};", imp.path).unwrap();
    }
    if !def.imports.is_empty() {
        writeln!(out).unwrap();
    }

    let word_type = word_type_for_width(def.config.width);
    let enum_name = format!("{}Instruction", def.config.name);

    // Enum definition
    writeln!(out, "#[derive(Debug, Clone, Copy, PartialEq, Eq)]").unwrap();
    writeln!(out, "pub enum {} {{", enum_name).unwrap();

    for instr in &def.instructions {
        let variant_name = to_pascal_case(&instr.name);
        if instr.resolved_fields.is_empty() {
            writeln!(out, "    {},", variant_name).unwrap();
        } else {
            let fields: Vec<String> = instr
                .resolved_fields
                .iter()
                .map(|f| {
                    let rust_type = field_rust_type(f);
                    format!("{}: {}", f.name, rust_type)
                })
                .collect();
            writeln!(out, "    {} {{ {} }},", variant_name, fields.join(", ")).unwrap();
        }
    }

    writeln!(out, "}}").unwrap();
    writeln!(out).unwrap();

    // impl block with decode()
    writeln!(out, "impl {} {{", enum_name).unwrap();
    writeln!(out, "    #[inline]").unwrap();
    writeln!(
        out,
        "    pub fn decode(opcode: {}) -> Option<Self> {{",
        word_type
    )
    .unwrap();

    emit_tree(&mut out, tree, def, &enum_name, 2);

    writeln!(out, "    }}").unwrap();
    writeln!(out, "}}").unwrap();

    out
}

/// Emit a decode tree node in block context (i.e. as a statement/expression, not a match arm).
fn emit_tree(
    out: &mut String,
    node: &DecodeNode,
    def: &ValidatedDef,
    enum_name: &str,
    indent: usize,
) {
    let pad = "    ".repeat(indent);
    match node {
        DecodeNode::Leaf { instruction_index } => {
            let instr = &def.instructions[*instruction_index];
            if let Some(guard) = leaf_guard(instr) {
                writeln!(out, "{}if {} {{", pad, guard).unwrap();
                emit_some(out, instr, enum_name, &format!("{}    ", pad));
                writeln!(out, "{}}} else {{", pad).unwrap();
                writeln!(out, "{}    None", pad).unwrap();
                writeln!(out, "{}}}", pad).unwrap();
            } else {
                emit_some(out, instr, enum_name, &pad);
            }
        }
        DecodeNode::Fail => {
            writeln!(out, "{}None", pad).unwrap();
        }
        DecodeNode::Branch {
            range,
            arms,
            default,
        } => {
            let extract_expr = extract_expression("opcode", *range);
            writeln!(out, "{}match {} {{", pad, extract_expr).unwrap();

            for (value, child) in arms {
                emit_arm(out, child, def, enum_name, indent + 1, &format!("{:#x}", value));
            }

            emit_arm(out, default, def, enum_name, indent + 1, "_");

            writeln!(out, "{}}}", pad).unwrap();
        }
    }
}

/// Emit a single match arm for a given pattern and child node.
fn emit_arm(
    out: &mut String,
    node: &DecodeNode,
    def: &ValidatedDef,
    enum_name: &str,
    indent: usize,
    pattern: &str,
) {
    let pad = "    ".repeat(indent);
    match node {
        DecodeNode::Fail => {
            writeln!(out, "{}{} => None,", pad, pattern).unwrap();
        }
        DecodeNode::Leaf { instruction_index } => {
            let instr = &def.instructions[*instruction_index];
            if let Some(guard) = leaf_guard(instr) {
                if pattern == "_" {
                    // Default arm with guard: emit guarded arm then fallback
                    write!(out, "{}{} if {} => ", pad, pattern, guard).unwrap();
                    emit_some_inline(out, instr, enum_name, indent);
                    writeln!(out, "{}{} => None,", pad, pattern).unwrap();
                } else {
                    write!(out, "{}{} if {} => ", pad, pattern, guard).unwrap();
                    emit_some_inline(out, instr, enum_name, indent);
                }
            } else {
                write!(out, "{}{} => ", pad, pattern).unwrap();
                emit_some_inline(out, instr, enum_name, indent);
            }
        }
        DecodeNode::Branch {
            range,
            arms,
            default,
        } => {
            writeln!(out, "{}{} => {{", pad, pattern).unwrap();
            let extract_expr = extract_expression("opcode", *range);
            let inner_pad = "    ".repeat(indent + 1);
            writeln!(out, "{}match {} {{", inner_pad, extract_expr).unwrap();

            for (value, child) in arms {
                emit_arm(out, child, def, enum_name, indent + 2, &format!("{:#x}", value));
            }

            emit_arm(out, default, def, enum_name, indent + 2, "_");

            writeln!(out, "{}}}", inner_pad).unwrap();
            writeln!(out, "{}}}", pad).unwrap();
        }
    }
}

/// Compute the guard condition string for a leaf instruction, if needed.
/// Returns `None` if all fixed bits were already fully dispatched by the tree.
fn leaf_guard(instr: &ValidatedInstruction) -> Option<String> {
    let fixed_bits = instr.fixed_bits();
    if fixed_bits.is_empty() {
        return None;
    }
    let (mask, value) = compute_mask_value(&fixed_bits);
    if mask == 0 {
        return None;
    }
    Some(format!("opcode & {:#x} == {:#x}", mask, value))
}

/// Write `Some(EnumName::Variant { ... })` as an inline match arm value (terminated with comma+newline).
fn emit_some_inline(
    out: &mut String,
    instr: &ValidatedInstruction,
    enum_name: &str,
    _indent: usize,
) {
    let variant_name = to_pascal_case(&instr.name);
    if instr.resolved_fields.is_empty() {
        writeln!(out, "Some({}::{}),", enum_name, variant_name).unwrap();
    } else {
        let fields: Vec<String> = instr
            .resolved_fields
            .iter()
            .map(|f| {
                let extract = extract_expression("opcode", f.range);
                let expr = apply_transforms(&extract, &f.resolved_type);
                format!("{}: {}", f.name, expr)
            })
            .collect();
        writeln!(
            out,
            "Some({}::{} {{ {} }}),",
            enum_name,
            variant_name,
            fields.join(", ")
        )
        .unwrap();
    }
}

/// Write `Some(EnumName::Variant { ... })` in block context (multi-line, no trailing comma).
fn emit_some(
    out: &mut String,
    instr: &ValidatedInstruction,
    enum_name: &str,
    pad: &str,
) {
    let variant_name = to_pascal_case(&instr.name);
    if instr.resolved_fields.is_empty() {
        writeln!(out, "{}Some({}::{})", pad, enum_name, variant_name).unwrap();
    } else {
        writeln!(out, "{}Some({}::{} {{", pad, enum_name, variant_name).unwrap();
        for field in &instr.resolved_fields {
            let extract = extract_expression("opcode", field.range);
            let expr = apply_transforms(&extract, &field.resolved_type);
            writeln!(out, "{}    {}: {},", pad, field.name, expr).unwrap();
        }
        writeln!(out, "{}}})", pad).unwrap();
    }
}

/// Compute a bitmask and expected value from a list of (hw_bit_position, Bit) pairs.
fn compute_mask_value(fixed_bits: &[(u32, Bit)]) -> (u64, u64) {
    let mut mask: u64 = 0;
    let mut value: u64 = 0;
    for &(bit_pos, bit_val) in fixed_bits {
        mask |= 1u64 << bit_pos;
        if bit_val == Bit::One {
            value |= 1u64 << bit_pos;
        }
    }
    (mask, value)
}

/// Generate an expression to extract bits from an opcode variable.
fn extract_expression(var: &str, range: BitRange) -> String {
    let width = range.width();
    let shift = range.end;
    let mask = (1u64 << width) - 1;

    if shift == 0 {
        format!("{} & {:#x}", var, mask)
    } else {
        format!("({} >> {}) & {:#x}", var, shift, mask)
    }
}

/// Apply transforms and type conversions to extracted field values.
fn apply_transforms(extract_expr: &str, resolved: &ResolvedFieldType) -> String {
    let mut expr = extract_expr.to_string();

    for transform in &resolved.transforms {
        match transform {
            Transform::SignExtend(n) => {
                let signed_type = signed_type_for(&resolved.base_type);
                let bits = type_bits(&resolved.base_type);
                expr = format!(
                    "((({} as {}) << ({} - {})) >> ({} - {}))",
                    expr, signed_type, bits, n, bits, n
                );
            }
            Transform::ZeroExtend(_) => {
                // No-op for unsigned types
            }
            Transform::ShiftLeft(n) => {
                expr = format!("(({}) << {})", expr, n);
            }
        }
    }

    if let Some(ref wrapper) = resolved.wrapper_type {
        expr = format!("{}::from(({}) as {})", wrapper, expr, resolved.base_type);
    } else if resolved.base_type == "bool" {
        expr = format!("({}) != 0", expr);
    } else {
        expr = format!("({}) as {}", expr, resolved.base_type);
    }

    expr
}

fn word_type_for_width(width: u32) -> &'static str {
    match width {
        8 => "u8",
        16 => "u16",
        32 => "u32",
        _ => "u32",
    }
}

fn signed_type_for(base: &str) -> &'static str {
    match base {
        "u8" | "i8" => "i8",
        "u16" | "i16" => "i16",
        "u32" | "i32" => "i32",
        _ => "i32",
    }
}

fn type_bits(base: &str) -> u32 {
    match base {
        "u8" | "i8" => 8,
        "u16" | "i16" => 16,
        "u32" | "i32" => 32,
        _ => 32,
    }
}

fn field_rust_type(field: &ResolvedField) -> String {
    if let Some(ref wrapper) = field.resolved_type.wrapper_type {
        wrapper.clone()
    } else {
        field.resolved_type.base_type.clone()
    }
}

/// Convert a DSL instruction name to PascalCase.
/// - `addi` → `Addi`
/// - `ld_b_c` → `LdBC`
/// - `ADD` → `Add`
pub fn to_pascal_case(name: &str) -> String {
    let mut result = String::new();
    let mut capitalize_next = true;

    for ch in name.chars() {
        if ch == '_' {
            capitalize_next = true;
        } else if capitalize_next {
            result.push(ch.to_ascii_uppercase());
            capitalize_next = false;
        } else {
            result.push(ch.to_ascii_lowercase());
        }
    }

    result
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_to_pascal_case() {
        assert_eq!(to_pascal_case("addi"), "Addi");
        assert_eq!(to_pascal_case("ld_b_c"), "LdBC");
        assert_eq!(to_pascal_case("ADD"), "Add");
        assert_eq!(to_pascal_case("nop"), "Nop");
    }

    #[test]
    fn test_extract_expression() {
        // Extract bits [5:0] (6 bits from position 5 down to 0)
        let range = BitRange::new(5, 0);
        assert_eq!(extract_expression("opcode", range), "opcode & 0x3f");

        // Extract bits [31:26] (6 bits from position 31 down to 26)
        let range = BitRange::new(31, 26);
        assert_eq!(
            extract_expression("opcode", range),
            "(opcode >> 26) & 0x3f"
        );
    }
}
