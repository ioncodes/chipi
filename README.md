# chipi

A declarative instruction decoder generator using a custom DSL. Define your CPUs instruction encoding in a `.chipi` file, and chipi generates a decoder for you. Seemless interaction with Rust types.

## Usage

Add to your `Cargo.toml`:

```toml
[build-dependencies]
chipi = "0.1"
```

In `build.rs`:

```rs
use std::env;
use std::path::PathBuf;

fn main() {
    let out_dir = PathBuf::from(env::var("OUT_DIR").unwrap());
    chipi::generate("ppc.chipi", out_dir.join("ppc.rs").to_str().unwrap())
        .expect("failed to generate decoder");
    println!("cargo:rerun-if-changed=ppc.chipi");
}
```

This will generate code like:

```rs
// Auto-generated by chipi. Do not edit.

use crate::cpu::Gpr;
use crate::cpu::Fpr;
use crate::cpu::CrField;

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum PpcInstruction {
    Addi { rd: Gpr, ra: Gpr, simm: i16 },
    Addis { rd: Gpr, ra: Gpr, simm: i16 },
// ...

impl GekkoInstruction {
    #[inline]
    pub fn decode(opcode: u32) -> Option<Self> {
        match (opcode >> 1) & 0x1f {
            0x0 => {
                match (opcode >> 26) & 0x3f {
                    0x4 => {
                        match (opcode >> 6) & 0x3 {
                            0x0 if opcode & 0xfc6007ff == 0x10000000 => Some(GekkoInstruction::PsCmpu0 { crfd: CrField::from(((opcode >> 23) & 0x7) as u8), fra: Fpr::from(((opcode >> 16) & 0x1f) as u8), frb: Fpr::from(((opcode >> 11) & 0x1f) as u8) }),
                            0x1 if opcode & 0xfc6007ff == 0x10000040 => Some(GekkoInstruction::PsCmpo0 { crfd: CrField::from(((opcode >> 23) & 0x7) as u8), fra: Fpr::from(((opcode >> 16) & 0x1f) as u8), frb: Fpr::from(((opcode >> 11) & 0x1f) as u8) }),
                            0x2 if opcode & 0xfc6007ff == 0x10000080 => Some(GekkoInstruction::PsCmpu1 { crfd: CrField::from(((opcode >> 23) & 0x7) as u8), fra: Fpr::from(((opcode >> 16) & 0x1f) as u8), frb: Fpr::from(((opcode >> 11) & 0x1f) as u8) }),
                            0x3 if opcode & 0xfc6007ff == 0x100000c0 => Some(GekkoInstruction::PsCmpo1 { crfd: CrField::from(((opcode >> 23) & 0x7) as u8), fra: Fpr::from(((opcode >> 16) & 0x1f) as u8), frb: Fpr::from(((opcode >> 11) & 0x1f) as u8) }),
                            _ => None,
                        }
                    }
                    0x7 if opcode & 0xfc000000 == 0x1c000000 => Some(GekkoInstruction::Mulli { rd: Gpr::from(((opcode >> 21) & 0x1f) as u8), ra: Gpr::from(((opcode >> 16) & 0x1f) as u8), simm: (opcode & 0xffff) as i16 
// ...
```

Then use it:

```rs
mod ppc {
    include!(concat!(env!("OUT_DIR"), "/ppc.rs"));
}

match ppc::PpcInstruction::decode(raw) {
    Some(i) => println!("{:?}", i),
    None => println!(".long {:#010x}", raw),
};
```

## DSL

Create a `.chipi` file describing your instruction set:

```chipi
import crate::cpu::Register

decoder Ppc {
    width = 32
    bit_order = msb0
}

type reg = u8 as Register
type simm16 = i32 { sign_extend(16) }

# Arithmetic
add    [0:5]=011111 rd:reg[6:10] ra:reg[11:15] rb:reg[16:20] [21:30]=0100001010 rc:u1[31]
addi   [0:5]=001110 rd:reg[6:10] ra:reg[11:15] simm:simm16[16:31]
```

- `decoder` block sets the instruction width (in bits) and bit ordering
- Each line defines an instruction: a name, fixed-bit patterns for matching, and named fields to extract
- Fields have a name, a type (`u8`, `u16`, ...), and a bit range
- Fixed bits use `[range]=value` syntax
- Comments start with `#`

### Bit ordering

- `msb0`: position 0 is the most significant bit
- `lsb0`: position 0 is the least significant bit

### Custom types

Use `type` to create type aliases with optional transformations or wrappers:

```chipi
# Simple alias
type byte = u8

# With transformation
type simm16 = i32 { sign_extend(16) }

# With custom wrapper (must be imported)
type reg = u8 as Register

# Multiple transformations (comma-separated)
type addr = u32 { shift_left(2), zero_extend(32) }
```

**Builtin types:**
- `bool`: Converts extracted bit to `bool`
- `u1` through `u7`: Extracted as `u8` in Rust
- `u8`, `u16`, `u32`: Unsigned integer types
- `i8`, `i16`, `i32`: Signed integer types

**Builtin transformations:**
- `sign_extend(n)`: Sign-extends the extracted value from n bits
- `zero_extend(n)`: Zero-extends the extracted value from n bits
- `shift_left(n)`: Shifts the value left by n bits

## Syntax Highlighting

[vscode](https://github.com/ioncodes/chipi-vscode)
